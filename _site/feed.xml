<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-02T09:44:51+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">张三的技术.博客</title><subtitle>张三的个人博客</subtitle><author><name>张艳冲</name></author><entry><title type="html">holmes服务性能指标监控，让bug无处遁行！</title><link href="http://localhost:4000/2023/03/23/holmes%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7/" rel="alternate" type="text/html" title="holmes服务性能指标监控，让bug无处遁行！" /><published>2023-03-23T00:00:00+08:00</published><updated>2023-03-23T00:00:00+08:00</updated><id>http://localhost:4000/2023/03/23/%20holmes%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7</id><content type="html" xml:base="http://localhost:4000/2023/03/23/holmes%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7/">&lt;p&gt;作为一名”懒惰”的程序员，如何避免在线上Golang系统半夜宕机 （一般是OOM导致的）时起床保存现场呢？又或者如何dump压测时性能尖刺时刻的profile文件呢？
holmes 或许能帮助您解决以上问题。&lt;/p&gt;

&lt;h1 id=&quot;holmes性能指标监控&quot;&gt;holmes性能指标监控&lt;/h1&gt;

&lt;h2 id=&quot;holmes是什么&quot;&gt;holmes是什么？&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;对于系统的性能尖刺问题，我们通常使用 Go 官方内置的 pprof 包进行分析，但是难点是对于一闪而过的“尖刺”，

开发人员很难及时保存现场：当你收到告警信息，从被窝中爬起来，打开电脑链接 VPN，系统说不定都已经重启三四趟了。

MOSN 社区的 Holmes 是一个基于 Golang 实现的轻量级性能监控系统，当应用的性能指标发生了异常波动时，

Holmes 会在第一时间保留现场，让你第二天上班可以一边做着大保健，一边追查问题的根因。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;快速入门&quot;&gt;快速入门&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;fmt&quot;
	&quot;mosn.io/holmes&quot;
	&quot;mosn.io/pkg/log&quot;
	&quot;net/http&quot;
	&quot;time&quot;
)

func init() {
	http.HandleFunc(&quot;/make1gb&quot;, make1gbslice)
	go http.ListenAndServe(&quot;:10003&quot;, nil)
}

var grReportCount int
var cpuReportCount int
var memReportCount int

type ReporterImpl struct{}

func (r *ReporterImpl) Report(pType string, buf []byte, reason string, eventID string) error {
	fmt.Println(fmt.Sprintf(&quot;call %s report \n&quot;, pType))

	switch pType {
	case &quot;goroutine&quot;:
		grReportCount++
	case &quot;cpu&quot;:
		cpuReportCount++
	case &quot;mem&quot;:
		memReportCount++

	}
	fmt.Println(&quot;type=&quot;, pType, &quot;reason=&quot;, reason, &quot;eventid=&quot;, eventID)
	fmt.Println(&quot;content =&quot;, string(buf))
	return nil

}
func main() {
	r := &amp;amp;ReporterImpl{} // a implement of holmes.ProfileReporter Interface.

	h, _ := holmes.New(
		holmes.WithProfileReporter(r),
		holmes.WithCollectInterval(&quot;2s&quot;),
		holmes.WithDumpPath(&quot;/tmp/holmes&quot;),
		//holmes.WithTextDump(),
		holmes.WithMemDump(3, 25, 80, time.Minute),
		holmes.WithCPUDump(1, 25, 80, time.Minute),
		holmes.WithGCHeapDump(10, 20, 40, time.Minute),
		holmes.WithGoroutineDump(5, 25, 20000, 0, time.Minute),
		holmes.WithLogger(holmes.NewFileLog(&quot;/tmp/holmes/holmes.log&quot;, log.ERROR)),
	)

	h.EnableCPUDump().
		EnableGoroutineDump().
		EnableMemDump().
		EnableGCHeapDump().Start()
	time.Sleep(time.Hour)

}

func make1gbslice(wr http.ResponseWriter, req *http.Request) {

	var a = make([]byte, 1073741824)
	_ = a
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;上面的代码是用来监控内存指标，超过咱们设置的规则，就会dump，并报警！
然后执行上面的代码，这样服务就被监控起来了，哈哈哈。

访问这个接口
http://127.0.0.1:10003/make1gb

你会发现在tmp/holmes目录下有个

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppDQs41&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/25/ppDQs41.png&quot; alt=&quot;ppDQs41.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;咱们现在进入该文件所在目录，开始分析这个文件

go tool pprof mem..20230325130917.601.log

使用 traces 就能很快找到内存泄漏的代码是哪一个，如下图所示
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppD1bnS&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/25/ppD1bnS.png&quot; alt=&quot;ppD1bnS.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二使用说明&quot;&gt;二、使用说明&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;类似于 holmes.WithGoroutineDump(min, diff, abs,max,2 * time.Minute) 的 API 
每个 Profile 都可以配置 min、diff、abs、coolDown 四个指标，含义如下:

当前指标小于 min 时，不视为异常。

当前指标大于 (100+diff)100% 历史指标，说明系统此时产生了波动，视为异常。

当前指标大于 abs (绝对值)时，视为异常。

CPU 和 Goroutine 这两个 Profile 类型提供 Max 参数配置，基于以下考虑：

CPU 的 Profiling 操作大约会有 5% 的性能损耗，所以当在 CPU 过高时，不应当进行 Profiling 操作，否则会拖垮系统。

当 Goroutine 数过大时，Goroutine Dump 操作成本很高，会进行 STW 操作，从而拖垮系统。（详情见文末参考文章）

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;三profile-types&quot;&gt;三、Profile Types&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Holmes 支持以下五种 Profile 类型，用户可以按需配置。

Mem: 内存分配

CPU: CPU 使用率

Thread: 线程数

Goroutine: 协程数

GCHeap: 基于 GC 周期监控的内存分配
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;四warming-up&quot;&gt;四、Warming up&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当 Holmes 启动时，会根据 CollectInterval 周期采集十次各项指标，在这期间内采集到的指标只会存入循环链表中，不会进行规则判断。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;五事件上报&quot;&gt;五、事件上报&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;您可以通过实现 Reporter 来实现以下功能：

发送告警信息，当 Holmes 触发 Dump 操作时。

将 Profiles 上传到其他地方，以防实例被销毁，从而导致 Profile 丢失，或进行分析。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
type ReporterImpl struct{}
        func (r *ReporterImple) Report(pType string, buf []byte, reason string, eventID string) error{
            // do something  
        }
        ......
        r := &amp;amp;ReporterImpl{} // a implement of holmes.ProfileReporter Interface.
      h, _ := holmes.New(
            holmes.WithProfileReporter(reporter),
            holmes.WithDumpPath(&quot;/tmp&quot;),
            holmes.WithLogger(holmes.NewFileLog(&quot;/tmp/holmes.log&quot;, mlog.INFO)),
            holmes.WithBinaryDump(),
            holmes.WithMemoryLimit(100*1024*1024), // 100MB
            holmes.WithGCHeapDump(10, 20, 40, time.Minute),
)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参考资料&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[1]《Holmes 文档》https://github.com/mosn/holmes

[2]《无人值守的自动 dump(一)》https://xargin.com/autodumper-for-go/

[3]《无人值守的自动 dump(二)》https://xargin.com/autodumper-for-go-ii/

[4]《go 语言 pprof heap profile 实现机制》https://uncledou.site/2022/go-pprof-heap/

[5]《goroutines pprofiling STW》https://github.com/golang/go/issues/33250

[6]《Holmes 使用案例文档》https://github.com/mosn/holmes/tree/master/example

[7]《go pprof 性能损耗》https://medium.com/google-cloud/continuous-profiling-of-go-programs-96d4416af77b


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>张艳冲</name></author><category term="go" /><summary type="html">作为一名”懒惰”的程序员，如何避免在线上Golang系统半夜宕机 （一般是OOM导致的）时起床保存现场呢？又或者如何dump压测时性能尖刺时刻的profile文件呢？ holmes 或许能帮助您解决以上问题。</summary></entry><entry><title type="html">这是用gin搭建的app用例,如果你是小白，那它适合你练手！</title><link href="http://localhost:4000/2023/03/22/%E5%B0%8F%E7%99%BD%E5%AD%A6%E4%B9%A0gin%E6%A1%86%E6%9E%B6%E5%86%99%E6%9C%8D%E5%8A%A1/" rel="alternate" type="text/html" title="这是用gin搭建的app用例,如果你是小白，那它适合你练手！" /><published>2023-03-22T00:00:00+08:00</published><updated>2023-03-22T00:00:00+08:00</updated><id>http://localhost:4000/2023/03/22/%20%E5%B0%8F%E7%99%BD%E5%AD%A6%E4%B9%A0gin%E6%A1%86%E6%9E%B6%E5%86%99%E6%9C%8D%E5%8A%A1</id><content type="html" xml:base="http://localhost:4000/2023/03/22/%E5%B0%8F%E7%99%BD%E5%AD%A6%E4%B9%A0gin%E6%A1%86%E6%9E%B6%E5%86%99%E6%9C%8D%E5%8A%A1/">&lt;p&gt;这是用gin搭建的app用例,如果你是小白，那它适合你练手！&lt;/p&gt;
&lt;h2 id=&quot;gin-框架文档&quot;&gt;gin 框架文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gin-gonic.com/docs&quot;&gt;https://gin-gonic.com/docs&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;新增日志中间件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新增recover中间件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新增异常捕获中间件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新增跨域中间件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新增热启动(执行make run即可)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新增平滑启动(kill -1 pid)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;一项目结构&quot;&gt;一、项目结构&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── Makefile
├── README.md
├── boot
│   └── boot.go
├── config
│   └── app.toml
├── docs
│   ├── docs.go
│   ├── swagger.json
│   └── swagger.yaml
├── go.mod
├── go.sum
├── internal
│   ├── api
│   │   └── order.go
│   ├── router
│   │   └── router.go
│   └── service
│       └── order.go
├── main.go
├── pkg
│   ├── cache
│   │   ├── cache.go
│   │   └── config.go
│   ├── db
│   │   ├── config.go
│   │   └── db.go
│   ├── gerror
│   │   ├── code.go
│   │   ├── gerror.go
│   │   └── msg.go
│   ├── logs
│   │   └── logs.go
│   ├── middleware
│   │   ├── catch.go
│   │   ├── logger.go
│   │   ├── middleware.go
│   │   └── recovery.go
│   ├── model
│   │   └── order.go
│   └── response
│       └── response.go
├── runtime
│   └── logs
│       ├── a-2023-02-27T10-28-57.646.log
│       ├── a-2023-02-27T10-29-01.987.log
│       ├── a-2023-02-27T10-29-05.857.log
│       ├── a-2023-02-27T10-41-41.139.log
│       └── a.log
└── swagger
    └── swagger.go

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;boot&quot;&gt;boot&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;项目启动包,配置初始化，mysql,redis初始化；
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;config&quot;&gt;config&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;项目的配置文件
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;internal&quot;&gt;internal&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;内部包目录,禁止其他go项目引入里面的包
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;pkg&quot;&gt;pkg&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;公共包目录，任何go项目都可引入公共包
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;二快速体验&quot;&gt;二、快速体验&lt;/h2&gt;

&lt;h3 id=&quot;1搭建go环境-mac下安装&quot;&gt;1）搭建go环境（ mac下安装）&lt;/h3&gt;

&lt;h4 id=&quot;1-1安装&quot;&gt;1-1、安装：&lt;/h4&gt;

&lt;p&gt;http://c.biancheng.net/view/3994.html&lt;/p&gt;

&lt;h4 id=&quot;1-2设置go环境变量&quot;&gt;1-2、设置go环境变量:&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  项目目录：{你的项目地址}/goweb,goweb目录下新建三个目录如下
  bin pkg src
  
  打开.bash_profile 文件写入以下go环境配置
 
  export GOROOT=/usr/local/go
  export GOPATH={你的项目地址}/goweb
  export GOBIN=$GOPATH/bin
  export PATH=$GOBIN:$PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;1-3开启go-mod&quot;&gt;1-3、开启go mod&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  export GO111MODULE=on
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;1-4设置拉取依赖库代理地址&quot;&gt;1-4、设置拉取依赖库代理地址&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;go env -w GOPROXY=https://goproxy.cn,direct
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-拉取项目&quot;&gt;2) 拉取项目&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone git@github.com:echo-music/go-blog.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3更新依赖包项目根目录下执行&quot;&gt;3）更新依赖包（项目根目录下执行)&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;go mod download
go mod tidy

注意:确保go.mod文件存在，否则执行 go mod init github.com/echo-music/go-blog ）

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4项目配置文件修改数据库redis配置&quot;&gt;4）项目配置文件,修改数据库，redis配置&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[app]
name = &quot;go_gin&quot;
port = 8081
version = &quot;1.0.0&quot;

[mysql]
type = &quot;mysql&quot;
link = &quot;root:123456@tcp(localhost:3306)/test&quot;
charset = &quot;utf8mb4&quot;
maxIdle = 10
maxOpen = 100
maxLifetime = &quot;30s&quot;

[redis]
host = &quot;127.0.0.1:6379&quot;
password = &quot;123456&quot;
db = 0

[logger]
fileName = &quot;./runtime/logs/a.log&quot;
maxSize = 1
maxBackups = 30
maxAges = 7
compress = true
level = &quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5项目跑起来项目根目录下执行&quot;&gt;5）项目跑起来（项目根目录下执行）&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## 项目首次启动运行该命令
make init

## 项目跑起来
make run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6-访问接口&quot;&gt;6) 访问接口&lt;/h3&gt;

&lt;p&gt;http://127.0.0.1:8081/orders/&lt;/p&gt;

&lt;h3 id=&quot;7-访问swagger接口文档&quot;&gt;7) 访问swagger接口文档&lt;/h3&gt;

&lt;p&gt;http://localhost:8081/swagger/index.html&lt;/p&gt;</content><author><name>张艳冲</name></author><category term="go" /><summary type="html">这是用gin搭建的app用例,如果你是小白，那它适合你练手！ gin 框架文档 https://gin-gonic.com/docs</summary></entry><entry><title type="html">性能分析工具pprof找出程序潜在的bug</title><link href="http://localhost:4000/2023/03/18/pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="alternate" type="text/html" title="性能分析工具pprof找出程序潜在的bug" /><published>2023-03-18T00:00:00+08:00</published><updated>2023-03-18T00:00:00+08:00</updated><id>http://localhost:4000/2023/03/18/%20pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8</id><content type="html" xml:base="http://localhost:4000/2023/03/18/pprof%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/">&lt;h1 id=&quot;性能分析工具pprof的使用&quot;&gt;性能分析工具pprof的使用&lt;/h1&gt;

&lt;h2 id=&quot;一什么是pprof&quot;&gt;一、什么是pprof？&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pprof可以对程序运行时占用CPU、内存、磁盘 IO、网络这些指标数据进行采样分析，并且提供了可视化的功能。
它包含了两个库：
1、runtime/pprof 对于只跑一次的程序，例如每天只跑一次的离线预处理程序，调用 pprof 包提供的函数，手动开启性能数据采集。
2、net/http/pprof 对于在线服务，对于一个 HTTP Server，访问 pprof 提供的 HTTP 接口，获得性能数据。
当然，实际上这里底层也是调用的 runtime/pprof 提供的函数，封装成接口对外提供网络访问。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;二影响程序性能指标数据有哪些&quot;&gt;二、影响程序性能指标数据有哪些？&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppwLHsA&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/23/ppwLHsA.png&quot; alt=&quot;ppwLHsA.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、当 CPU 性能分析启用后，Go runtime 会每 10ms 就暂停一下，记录当前运行的 goroutine 的调用堆栈及相关数据。
   当性能分析数据保存到硬盘后，我们就可以分析代码中的热点了。
2、内存性能分析则是在堆（Heap）分配的时候，记录一下调用堆栈。默认情况下，是每 1000 次分配，取样一次，这个数值可以改变。
  栈(Stack)分配 由于会随时释放，因此不会被内存分析所记录。由于内存分析是取样方式，并且也因为其记录的是分配内存，而不是使用内存。
  因此使用内存性能分析工具来准确判断程序具体的内存使用是比较困难的。   
3、阻塞分析是一个很独特的分析，它有点儿类似于 CPU 性能分析，但是它所记录的是 goroutine 等待资源所花的时间。
  阻塞分析对分析程序并发瓶颈非常有帮助，阻塞性能分析可以显示出什么时候出现了大批的 goroutine 被阻塞了。阻塞性能分析是特殊的分析工具，
  在排除 CPU 和内存瓶颈前，不应该用它来分析。  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;三pprof如何使用&quot;&gt;三、pprof如何使用？&lt;/h2&gt;

&lt;h3 id=&quot;runtimepprof&quot;&gt;runtime/pprof&lt;/h3&gt;

&lt;p&gt;1、创建一个main.go文件,编写如下代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main(){
	f, _ := os.OpenFile(&quot;cpu.profile&quot;, os.O_CREATE|os.O_RDWR, 0644)
	defer f.Close()
	pprof.StartCPUProfile(f)
	defer pprof.StopCPUProfile()
	sayHellowold()
 
 }
 func sayHellowold() {
	hellowold(10000)
	say(100000)
}

func hellowold(times int) {
	time.Sleep(time.Second * 2)
	var counter int
	for i := 0; i &amp;lt; times; i++ {
		for j := 0; j &amp;lt; times; j++ {
			counter++
		}
	}
}

func say(times int) {
	time.Sleep(time.Second * 2)
	var counter int
	for i := 0; i &amp;lt; times; i++ {
		for j := 0; j &amp;lt; times; j++ {
			counter++
		}
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2、使用go run main.go执行程序&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; go run main.go 生成需要分析的cpu或内存的文件 
 example: cpu.profile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppNJssJ&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/20/ppNJssJ.png&quot; alt=&quot;ppNJssJ.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、对采集的程序指标数据进行分析&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 另启一个终端 go tool pprof [文件路径] 分析cpu 或内存的使用情况
 example:  go tool pprof  cpu.profile|pprof.samples.cpu.032.pb.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppNY3Y6&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/20/ppNY3Y6.png&quot; alt=&quot;ppNY3Y6.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;发现cpu执行时间较长的是say函数,使用list main.say查看详情：
&lt;a href=&quot;https://imgse.com/i/ppNYDtP&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/20/ppNYDtP.png&quot; alt=&quot;ppNYDtP.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;nethttppprof&quot;&gt;net/http/pprof&lt;/h3&gt;

&lt;p&gt;1、创建一个main.go文件,编写如下代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func main() {

	http.HandleFunc(&quot;/&quot;, sayHelloHandler) //	设置访问路由
	log.Fatal(http.ListenAndServe(&quot;:9999&quot;, nil))

}

func sayHelloHandler(w http.ResponseWriter, r *http.Request) {

	hellowold(10000)
	fmt.Println(&quot;path&quot;, r.URL.Path)
	fmt.Println(&quot;scheme&quot;, r.URL.Scheme)
	fmt.Fprintf(w, &quot;Hello world!\n&quot;) //这个写入到w的是输出到客户端的
	say(100000)
}

func hellowold(times int) {
	time.Sleep(time.Second * 2)
	var counter int
	for i := 0; i &amp;lt; times; i++ {
		for j := 0; j &amp;lt; times; j++ {
			counter++
		}
	}
}

func say(times int) {
	time.Sleep(time.Second * 2)
	var counter int
	for i := 0; i &amp;lt; times; i++ {
		for j := 0; j &amp;lt; times; j++ {
			counter++
		}
	}
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2、使用go run main.go执行程序&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;服务启动后，直接在浏览器上访问：

http://localhost:9999/debug/pprof/

得到了一个性能指标数据的汇总页面。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppwOOX9&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/23/ppwOOX9.png&quot; alt=&quot;ppwOOX9.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;可以直接点击上面的链接，进入子页面，查看相关的汇总信息。

关于 goroutine 的信息有两个链接，goroutine 和 full goroutine stack dump，前者是一个汇总的消息，可以查看 goroutines 的总体情况，后者则可以看到每一个 goroutine 的状态
点击 profile 和 trace 则会在后台进行一段时间的数据采样(默认30秒)，采样完成后，返回给浏览器一个 profile 文件，之后在本地通过 go tool pprof 工具进行分析。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppwXntf&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/23/ppwXntf.png&quot; alt=&quot;ppwXntf.png&quot; /&gt;&lt;/a&gt;
然后使用list查看命令占用cpu时间最长的函数的时间消耗详情
&lt;a href=&quot;https://imgse.com/i/ppwX4jH&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/23/ppwX4jH.png&quot; alt=&quot;ppwX4jH.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当然如果不想通过浏览器下载，也可以通过交互模式采集并下载要分析的指标数据文件

go tool pprof http://localhost:9999/debug/pprof/profile

默认采集时间30秒，当然你可以重新设置采集时间，像下面这样：
go tool pprof http://localhost:9999/debug/pprof/profile\?seconds\=60

其他采集命令：
# 下载 cpu profile，默认从当前开始收集 30s 的 cpu 使用情况，需要等待 30s
go tool pprof http://localhost:9999/debug/pprof/profile
# wait 120s
go tool pprof http://localhost:9999/debug/pprof/profile?seconds=120     

# 下载 heap profile
go tool pprof -inuse_space http://127.0.0.1:9999/debug/pprof/heap\?seconds\=60
go tool pprof http://localhost:9999/debug/pprof/heap

# 下载 goroutine profile
go tool pprof http://localhost:9999/debug/pprof/goroutine

# 下载 block profile
go tool pprof http://localhost:9999/debug/pprof/block

# 下载 mutex profile
go tool pprof http://localhost:9999/debug/pprof/mutex



在采集的过程中，也别忘了访问你觉得有性能的接口，比如

http://localhost:9999/

采集完成后会直接进入交互模式。如下图所示：
红框部分就行采集后生成的cpu性能指标数据文件

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppwvFeA&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/23/ppwvFeA.png&quot; alt=&quot;ppwvFeA.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果在以上交互模式下退出，还可以继续使用如下命令进入交互模式
go tool pprof [文件路径] 分析cpu 或内存的使用情况,比如下面例子：
go tool pprof /Users/liufangting/pprof/pprof.samples.cpu.042.pb.gz  

如果不想在终端交互模式下做指标数据性能分析，那还可以在浏览器里进行交互
go tool pprof -http :8081  [采集信息文件路径]或者 采集url

example:
go tool pprof -http :8081 cpu.profile
go tool pprof -http :8081 /Users/liufangting/pprof/pprof.samples.cpu.042.pb.gz
go tool pprof -http :8081  http://localhost:8080/debug/pprof/profile\?seconds\=60
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppwzVxS&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/23/ppwzVxS.png&quot; alt=&quot;ppwzVxS.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3 如果查看火焰图？&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，下方就是正在执行的函数，顶部都是它的父函数
  x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。
  火焰图就是看顶层的哪个函数占据的宽度最大。只要有&quot;平顶&quot;（plateaus），就表示该函数可能存在性能问题
  
  //https://www.ruanyifeng.com/blog/2017/09/flame-graph.html
  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppwzOds&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/23/ppwzOds.png&quot; alt=&quot;ppwzOds.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4 测试代码地址&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/echo-music/go-learn/blob/master/monitor/pprofs/cmd/main.go&quot;&gt;示例完整代码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;总结
使用pprof进行性能指标分析两大步：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;第一步：性能指标数据采集
1、代码中采集并保存文件；runtime/pprof
2、终端采集自动生成可分析的指标数据文件；net/http/pprof
3、web端访问击 profile 和 trace 采集；net/http/pprof

第一步：对采集的性能指标数据进行分析
1、终端交互模式下使用top,list,traces 分析；
2、web端交互模式下，查看火焰图，程序的调用图进行性能分析；
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>张艳冲</name></author><category term="go" /><summary type="html">性能分析工具pprof的使用</summary></entry><entry><title type="html">小白学习docker入门到放弃</title><link href="http://localhost:4000/2023/03/17/docker%E5%B0%8F%E7%99%BD%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/" rel="alternate" type="text/html" title="小白学习docker入门到放弃" /><published>2023-03-17T00:00:00+08:00</published><updated>2023-03-17T00:00:00+08:00</updated><id>http://localhost:4000/2023/03/17/%20docker%E5%B0%8F%E7%99%BD%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0</id><content type="html" xml:base="http://localhost:4000/2023/03/17/docker%E5%B0%8F%E7%99%BD%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/">&lt;h2 id=&quot;docker-自学笔记&quot;&gt;docker 自学笔记&lt;/h2&gt;

&lt;h3 id=&quot;一docker-安装&quot;&gt;一、docker 安装&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、mac下安装
brew install docker

2、docker配置
{
  &quot;builder&quot;: {
    &quot;gc&quot;: {
      &quot;defaultKeepStorage&quot;: &quot;20GB&quot;,
      &quot;enabled&quot;: true
    }
  },
  &quot;experimental&quot;: false,
  &quot;features&quot;: {
    &quot;buildkit&quot;: true
  },
  &quot;insecure-registries&quot;: [
    &quot;127.0.0.1:5000&quot;
  ],
  &quot;registry-mirrors&quot;: [
    &quot;https://dfggrvdfvdf.mirror.aliyuncs.com&quot;
  ]
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;二容器三要素&quot;&gt;二、容器三要素&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;容器，镜像，仓库
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;三ubuntu-安装&quot;&gt;三、ubuntu 安装&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1、拉镜像
 docker pull ubuntu
 
 2、使用镜像创建ubuntu容器
 docker run -it --name=mylinux -d ubuntu  /bin/bash
 
 3、查看运行的所有容器
 docker ps -a
 
 4、进入容器交互终端
 docker exec -it mylinux /bin/bash
 
 5、强制删除容器
 docker rm -f mylinux
 
 6、停止容器
 docker stop  mylinux
 
 7、删除容器
 docker rm mylinux
 
 8、查看容器的进程
 docker top mylinux
 
 9、将容器的内容拷贝到宿主机
 docker cp 00293c6120d5:/home/a.txt  /tmp/
 
 10、将容器被导出
 docker export 00293c6120d5 &amp;gt; abc.tar
 
 11、将容器导出镜像
 cat abc.tar| docker import - lft/ubuntu:3.9
 
 12、还原容器
 docker run -it --name=newlinux -d a97f0637883b  /bin/bash
 
 
 13、提交容器副本
 docker commit -m=&quot;new linux image&quot; -a=&quot;zhangsan&quot; 8ab3fe9feda7 newubuntu:1.8
 
 14、启动新生成的镜像
 docker run -it --name=mylinux -d  9bb4ce12c704  /bin/bash
 
 注意⚠️
 docker exec 不会退出容器
 docker attach 会退出容器
 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;四私有库搭建&quot;&gt;四、私有库搭建&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  1、docker pull registry
  
  2、docker run -d --name registry -p 5000:5000 -v /tmp/docker/registry:/tmp/registry registry
  
  3、docker tag hello:v1 127.0.0.1:5000/hello:v1
  
  4、配置daemon.json并重启docker
  { 
    &quot;insecure-registries&quot; : [ &quot;your-server-ip:5000&quot; ] 
  }
  
  5、推送到私有库
  docker push 127.0.0.1:5000/hello:v1
  
  6、拉取镜像
  docker pull 127.0.0.1:5000/hello:v1
    
  7、跑起来  
  docker run -it --name hello -p 8080:8080 -d 127.0.0.1:5000/hello:v1
  
    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;五容器卷&quot;&gt;五、容器卷&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1、目录挂载
 docker run -it --name mylinux  --privileged=true -v /tmp/mylinux/data:/tmp/data ubuntu /bin/bash

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;六安装tomcat&quot;&gt;六、安装tomcat&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -it --name mytomcat  -p 8888:8080 -d tomcat:8.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;七安装mysql&quot;&gt;七、安装mysql&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、简单安装
docker run --name my-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql:8.0

2、企业级安装
docker run -d -p 3306:3306 --privileged=true \
-v /Users/liufangting/home/mysql/log:/var/log/mysql \
-v /Users/liufangting/home/mysql/data:/var/lib/mysql \
-v /Users/liufangting/home/mysql/conf:/etc/mysql/conf.d \
-e MYSQL_ROOT_PASSWORD=123456 \
--name mysql-master \
mysql


[client]
default-character-set=utf8

[mysqld]
character-set-server=utf8
default-storage-engine=INNODB


3、集群步骤
1)新建mysql主服务
docker run -d -p 3307:3306 --privileged=true \
-v /Users/liufangting/home/mysql/3307/log:/var/log/mysql \
-v /Users/liufangting/home/mysql/3307/data:/var/lib/mysql \
-v /Users/liufangting/home/mysql/3307/conf:/etc/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
--name mysql-master \
mysql:5.7
2)mysql-master的文件配置


3)mysql-master重启
docker restart mysql-master

4)登陆-mysql-master创建从服务账号

CREATE USER &apos;slave&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;
#给master用户配置复制权限,可访问库为所有,可访问地址为所有
grant replication slave ,replication client on *.* to &apos;slave&apos;@&apos;%&apos;;

5)新建从服务器
docker run -d -p 3308:3306 --privileged=true \
-v /Users/liufangting/home/mysql/3308/log:/var/log/mysql \
-v /Users/liufangting/home/mysql/3308/data:/var/lib/mysql \
-v /Users/liufangting/home/mysql/3308/conf:/etc/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
--name mysql-slave \
mysql:5.7

6)修改mysql-slave文件的配置
[mysqld]
## 设置server ID 同一局域网中需要唯一
server_id=102
## 指定不需要同步的数据库名称
binlog-ignore-db=mysql
## 开启二进制日志功能
log-bin=mall-mysql-bin
## 设置二进制日志使用内存大小
binlog_cache_size=1M
## 设置使用二进制的日志格式
binlog_format=mixed
## 二进制日志过期清理时间
expire_logs_days=7
## 跳过主层复制遇到的错误
slave_skip_errors=1062

## 配置中继日志
reply_log=mall-mysql-repay-bin
##slave 将复制事件写进自己的二进制日志
log_slave_updates=1
## slave设置为只读
read_only=1

7)重启mysql-slave
docker restart mysql-slave


8)登陆mysql-master查看同步状态
show master status;

9)从数据库配置主层复制

change master to master_host=&quot;172.17.0.2&quot;,
master_user=&quot;slave&quot;,master_password=&apos;123456&apos;,master_port=3306,
master_log_file=&apos;mall-mysql-bin.000001&apos;,master_log_pos=1097,
master_connect_retry=30;


show slave status\G;
Slave_IO_Running: No
Slave_SQL_Running: No

10)从数据库开启主从同步
start slave

show slave status\G;

Slave_IO_Running: Yes
Slave_SQL_Running: Yes

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;八redis-安装&quot;&gt;八、redis 安装&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、拉取镜像
docker pull redis

2、简单安装redis服务
docker run -it --name myredis -d redis

3、企业级安装
docker run -d -p 6379:6379  --privileged=true \
-v /Users/liufangting/home/redis/conf:/usr/local/etc/redis \
-v /Users/liufangting/home/redis/data:/data \
--name myredis redis redis-server /usr/local/etc/redis/redis.conf 
  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;九docker自定义网络&quot;&gt;九、docker自定义网络&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、新建网络
docker network create lft

2、使用自己新建的网络运行容器
docker run -it --name mytomcat  -p 8888:8080  --network lft -d tomcat:8.0

docker run -it --name mytomcat2  -p 8889:8080  --network lft -d tomcat:8.0

docker exec -it mytomcat /bin/bash

ping mytomcat2

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;十docker-compose-使用&quot;&gt;十、docker-compose 使用&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; mac桌面版已经安装了docker-compose
 
 1、开发微服务项目
 
 2、配置dockerfile文件生成镜像
 
 3、配置docker-compose文件启动容器
  docker-compose up
  相当于把多个docker run 一健运行
  
  

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;十一监控docker容器&quot;&gt;十一、监控docker容器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -p 9000:9000 -p 8000:8000 --name portainer \
--restart=always \
-v /var/run/docker.sock:/var/run/docker.sock \
-v /Users/liufangting/home/portainer/data:/data \
-d portainer/portainer
 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;十二使用docker创建etcd容器&quot;&gt;十二、使用docker创建etcd容器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;version: &apos;3&apos;

networks:
  etcd-network:

services:
  etcd:
    container_name: &quot;etcd_server&quot;
    image: bitnami/etcd:latest
    privileged: true
    ports:
      - &quot;2379:2379&quot;
      - &quot;2380:2380&quot;
    environment:
      - &quot;ETCD_ADVERTISE_CLIENT_URLS=http://0.0.0.0:2379&quot;
      - &quot;ETCD_LISTEN_CLIENT_URLS=http://0.0.0.0:2379&quot;
      - &quot;ETCD_LISTEN_PEER_URLS=http://0.0.0.0:2380&quot;
      - &quot;ETCD_INITIAL_ADVERTISE_PEER_URLS=http://0.0.0.0:2380&quot;
      - &quot;ALLOW_NONE_AUTHENTICATION=no&quot;
      - &quot;ETCD_ROOT_PASSWORD=123456&quot;

    volumes:
      - /Users/liufangting/home/etcd3/data:/bitnami/etcd/data
    networks:
      - etcd-network
  etcd_keeper:
    hostname: etcdkeeper
    container_name: &quot;etcdkeeper&quot;
    image: evildecay/etcdkeeper:latest
    ports:
      - &quot;8099:8080&quot;
    networks:
      - etcd-network


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;十三etcd管理界面&quot;&gt;十三、etcd管理界面&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppNlO00&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/20/ppNlO00.png&quot; alt=&quot;ppNlO00.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;web ui

需要指定etcd服务地址，这里我指定容器名称，因为etcd keeper 和etcd是在同一网络下，所以可以通过
容器名称作为域名，是互相能ping通的

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>张艳冲</name></author><category term="docker" /><summary type="html">docker 自学笔记</summary></entry><entry><title type="html">mongo的备份与恢复</title><link href="http://localhost:4000/2022/09/08/mongo%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" rel="alternate" type="text/html" title="mongo的备份与恢复" /><published>2022-09-08T00:00:00+08:00</published><updated>2022-09-08T00:00:00+08:00</updated><id>http://localhost:4000/2022/09/08/mongo%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D</id><content type="html" xml:base="http://localhost:4000/2022/09/08/mongo%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/">&lt;h2 id=&quot;1mongo-分片-备份--和--恢复&quot;&gt;1.mongo 分片 备份  和  恢复&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;备份指定库   
	
mongodump --host 127.0.0.1 --port 27000  -d zyc -o /zyc/mongo_share/tmp  
它会在/tmp/目录下面生成一个mydb的目录   
	 
备份所有库   
mongodump --host 127.0.0.1 --port 20000 -o /tmp/mongobak/alldatabase   
	 
指定备份集合   
mongodump --host 127.0.0.1 --port 20000 -d mydb -c c1 -o /tmp/mongobak/   
它依然会生成mydb目录，再在这目录下面生成两个文件   
	
导出集合为json文件   
mongoexport --host 127.0.0.1 --port 20000 -d mydb -c c1 -o /tmp/mydb2/1.json 


	
恢复所有库   
mongorestore -h 127.0.0.1 --port 20000 --drop dir/ //其中dir是备份所有库的目录名字，其中--drop可选，意思是当恢复之前先把之前的数据删除，不建议使用   
	
恢复指定库   mongorestore -d zyc /zyc/mongo_share/tmp/zyc  //-d跟要恢复的库名字，dir就是该库备份时所在的目录  
	
恢复集合  mongorestore -d mydb -c testc dir/mydb/testc.bson // -c后面跟要恢复的集合名字，dir是备份mydb库时生成文件所在路径，这里是一个bson文件的路径   
	
导入集合   mongoimport -d mydb -c testc --file /tmp/testc.json  

恢复带密码的指定库 
/mnt/mongo_share/mongodb42/bin/mongorestore   -h 127.0.0.1:27017  -d calorie_log /mnt/bak_mongo_data/20210127/calorie_log   -u 用户名 -p 密码  --authenticationDatabase admin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>张艳冲</name></author><category term="mongo" /><summary type="html">1.mongo 分片 备份 和 恢复</summary></entry><entry><title type="html">go语言内存逃逸场景分析</title><link href="http://localhost:4000/2022/05/06/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%9C%BA%E6%99%AF/" rel="alternate" type="text/html" title="go语言内存逃逸场景分析" /><published>2022-05-06T00:00:00+08:00</published><updated>2022-05-06T00:00:00+08:00</updated><id>http://localhost:4000/2022/05/06/%20%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%9C%BA%E6%99%AF</id><content type="html" xml:base="http://localhost:4000/2022/05/06/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E5%9C%BA%E6%99%AF/">&lt;p&gt;内存逃逸是由编译器来决定内存分配的位置（是在栈上还是在堆上分配内存），而不是由程序员来决定的！
在函数中申请一个新的对象：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、如果分配在栈中，则函数执行结束后可自行将内存回收
2、如果分配在堆中，则函数执行结束后可交给GC(垃圾回收)处理。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;内存逃逸场景&quot;&gt;内存逃逸场景&lt;/h1&gt;

&lt;h2 id=&quot;1指针逃逸&quot;&gt;1、指针逃逸&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;我们知道Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例。

type Student struct {
	Name string
}

func Say() *Student {
	stu := Student{}
	stu.Name = &quot;张三&quot;
	return &amp;amp;stu
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppwnhE6&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/23/ppwnhE6.png&quot; alt=&quot;ppwnhE6.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2栈空间不足逃逸&quot;&gt;2、栈空间不足逃逸&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;很多函数的参数为interface 类型，比如 fmt.Println(a ...interface{}),编译期间很难确定其参数的具体类型，也会产生逃逸

func slice() {
	s := make([]int, 10000, 10000)

	for index, _ := range s {
		s[index] = index
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppwnjVP&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/23/ppwnjVP.png&quot; alt=&quot;ppwnjVP.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3动态类型逃逸&quot;&gt;3、动态类型逃逸&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s := &quot;sbc&quot;
fmt.Println(s)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppwuEV0&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/23/ppwuEV0.png&quot; alt=&quot;ppwuEV0.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;4闭包引用对象逃逸&quot;&gt;4、闭包引用对象逃逸&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func bibao() func() int {
	a, b := 0, 1

	return func() int {
		a, b = b, a+b
		return a
	}
}

该函数返回一个闭包，闭包引用了函数的局部变量a和b,使用时通过该函数获取闭包,a,b只能放到堆中，所以产生了逃逸。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://imgse.com/i/ppwunGF&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2023/03/23/ppwunGF.png&quot; alt=&quot;ppwunGF.png&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;小结：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;栈上分配内存比在堆中分配内存有更高的效率；
栈上分配的内存不需要GC处理；
逃逸分析的目的是决定分配地址是栈还是堆；
逃逸分析在编译阶段完成；

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>张艳冲</name></author><category term="go" /><summary type="html">内存逃逸是由编译器来决定内存分配的位置（是在栈上还是在堆上分配内存），而不是由程序员来决定的！ 在函数中申请一个新的对象： 1、如果分配在栈中，则函数执行结束后可自行将内存回收 2、如果分配在堆中，则函数执行结束后可交给GC(垃圾回收)处理。</summary></entry><entry><title type="html">你说你会用反射，我觉得你在吹牛逼</title><link href="http://localhost:4000/2022/01/20/%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%98%AF%E5%90%A6%E7%94%A8%E5%88%B0%E4%BA%86%E5%8F%8D%E5%B0%84/" rel="alternate" type="text/html" title="你说你会用反射，我觉得你在吹牛逼" /><published>2022-01-20T00:00:00+08:00</published><updated>2022-01-20T00:00:00+08:00</updated><id>http://localhost:4000/2022/01/20/%20%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%98%AF%E5%90%A6%E7%94%A8%E5%88%B0%E4%BA%86%E5%8F%8D%E5%B0%84</id><content type="html" xml:base="http://localhost:4000/2022/01/20/%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%98%AF%E5%90%A6%E7%94%A8%E5%88%B0%E4%BA%86%E5%8F%8D%E5%B0%84/">&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;我想让你知道：
1、反射可以将interface类型变量转换称反射对象
2、反射可以将反射对象还原成interface对象
3、反射对象可以修改，value值必须是可设置的

那么什么是反射呢？接下来就让我们开启反射之旅吧

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;一什么是反射&quot;&gt;一、什么是反射？&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），
并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。每种语言的反射模型都不同，并且有些语言根本不支持反射。Golang语言实现了反射，
反射机制就是在运行时动态的调用对象的方法和属性，官方自带的reflect包就是反射相关的，只要包含这个包就可以使用。

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;二反射的使用场景&quot;&gt;二、反射的使用场景&lt;/h2&gt;

&lt;h3 id=&quot;1动态初始化结构体数值&quot;&gt;1、动态初始化结构体数值&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;通常我们做业务开发的时候，需要定义表字段的状态值，如果一个个手动设置很麻烦！
那么我们通过反射来动态初始化字段的状态值，做到状态统一管理。比如订单的状态会有多个
case，那么接下来咱们用反射来实现多个状态case初始化

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;fmt&quot;
	&quot;github.com/stoewer/go-strcase&quot;
	&quot;reflect&quot;
)

type orderState struct {
	Closed  string
	WaitPay string
	Paid    string
	Cancel  string
}

var OrderStates orderState

func main() {

	v := reflect.ValueOf(&amp;amp;OrderStates).Elem()
	//订单状态动态初始化
	initStrAttr(v)
	fmt.Println(OrderStates)
	//out {closed wait_pay paid cancel}

}

func initStrAttr(v reflect.Value) {
	for i := 0; i &amp;lt; v.NumField(); i++ {
		t := v.Field(i).Kind()
		name := v.Type().Field(i).Name
		if v.Field(i).Kind() == reflect.String {
			v.Field(i).SetString(strcase.SnakeCase(name))
		} else {
			panic(fmt.Sprintf(&quot;结构体字段 %s 类型必须为字符串,而不是%s&quot;, name, t))
		}

	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2数据导出到excel&quot;&gt;2、数据导出到excel&lt;/h3&gt;
&lt;p&gt;每次产品让导出不同表数据的时候，总要写一套导出的逻辑，干着吃力不讨好事情，没意思！那么有没有满足万能导出的方案呢？
我说有，可以通过反射来实现！看下面的案例，教你如果写出万能导出数据到excel代码。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package main

import (
	&quot;fmt&quot;
	&quot;github.com/xuri/excelize/v2&quot;
	&quot;math/rand&quot;
	&quot;reflect&quot;
	&quot;time&quot;
)

type DocumentRow struct {
	Id          string `json:&quot;id&quot; h:&quot;章节ID&quot;`          //章节ID
	Name        string `json:&quot;name&quot; h:&quot;标题&quot;`          //标题
	Author      string `json:&quot;author&quot; h:&quot;作者&quot;`        //作者
	Logo        string `json:&quot;logo&quot; h:&quot;封面图片&quot;`        //封面图片
	LogoUrl     string `json:&quot;logo_url&quot; h:&quot;封面地址&quot;`    //封面地址
	Description string `json:&quot;description&quot; h:&quot;文章描述&quot;` //文章描述
	Type        string `json:&quot;type&quot; h:&quot;类型&quot;`          //类型
	TypeValue   string `json:&quot;type_value&quot; h:&quot;类型值&quot;`   //类型值
	Status      string `json:&quot;status&quot; h:&quot;状态&quot;`        //状态
	StatusValue string `json:&quot;status_value&quot; h:&quot;状态值&quot;` //状态值
	CreatorName string `json:&quot;creator_name&quot; h:&quot;创建人&quot;` //创建人
	OnAt        string `json:&quot;on_at&quot; h:&quot;上架时间&quot;`       //上架时间
	Views       int    `json:&quot;views&quot; h:&quot;章节浏览次数&quot;`     //章节浏览次数
	Weight      int    `json:&quot;weight&quot; h:&quot;排序权重&quot;`      //排序权重

}

func getData(num int) []DocumentRow {

	var list = make([]DocumentRow, 0, num)

	for i := 0; i &amp;lt; num; i++ {
		r := rand.New(rand.NewSource(time.Now().UnixNano()))
		no := r.Intn(9999999-8888888) + 8888888

		list = append(list, DocumentRow{
			Id:          fmt.Sprintf(&quot;%d&quot;, i),
			Name:        fmt.Sprintf(&quot;文章_%d&quot;, no),
			Author:      &quot;张三&quot;,
			Logo:        &quot;&quot;,
			LogoUrl:     &quot;&quot;,
			Description: &quot;&quot;,
			Type:        &quot;&quot;,
			TypeValue:   &quot;&quot;,
			Status:      &quot;&quot;,
			StatusValue: &quot;&quot;,
			CreatorName: &quot;&quot;,
			OnAt:        &quot;&quot;,
			Views:       0,
			Weight:      0,
		})

	}

	return list

}

func main() {

	data := getData(100)
	ExportExcel(&quot;./document.xlsx&quot;, &quot;文章列表&quot;, data)

}

// ExportExcel 数据导出到excel
// filePath 保存的路径
// sheetName 工作标名称
// data 要导的数据
func ExportExcel(filePath, sheetName string, data interface{}) {

	v := reflect.ValueOf(data)
	if v.Kind() != reflect.Slice {
		panic(&quot;not slice&quot;)
	}

	if v.Len() == 0 {
		return
	}

	f := excelize.NewFile()
	err := f.SetSheetName(&quot;Sheet1&quot;, sheetName)
	if err != nil {
		panic(err)
	}
	t := v.Index(0).Type()
	heads := make([]interface{}, 0, t.NumField())
	for i := 0; i &amp;lt; v.Len(); i++ {
		item := make([]interface{}, 0, t.NumField())
		for j := 0; j &amp;lt; t.NumField(); j++ {
			if i == 0 {
				name := t.Field(j).Tag.Get(&quot;h&quot;)
				heads = append(heads, name)
			}
			item = append(item, v.Index(i).Field(j))
		}
		if i == 0 {
			if err = f.SetSheetRow(sheetName, fmt.Sprintf(&quot;A%d&quot;, 1), &amp;amp;heads); err != nil {
				panic(err)
			}
		}
		if err = f.SetSheetRow(sheetName, fmt.Sprintf(&quot;A%d&quot;, i+2), &amp;amp;item); err != nil {
			panic(err)
		}
	}

	if err = f.SaveAs(filePath); err != nil {
		panic(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3excel导入到数据库&quot;&gt;3、excel导入到数据库&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package reflects

import (
	&quot;github.com/xuri/excelize/v2&quot;
	&quot;reflect&quot;
	&quot;strings&quot;
)

type Title struct {
	Index      int    //当前行记录第i列索引下标
	Field      string //struct 字段名字
	FieldIndex int    //struct 字段下标
	Name       string //excel 头部标题
}

func ImportDb(filePath string, data any) {

	v := reflect.ValueOf(data).Elem()
	if v.Kind() != reflect.Slice {
		panic(&quot;hello&quot;)
	}

	t := v.Type().Elem()

	f, err := excelize.OpenFile(filePath)
	if err != nil {
		println(err.Error())
		return
	}
	// 获取 Sheet1 上所有单元格
	rows, err := f.GetRows(&quot;Sheet1&quot;)
	if len(rows) == 0 {
		panic(&quot;暂无数据&quot;)
	}

	if t.NumField() != len(rows[0]) {
		panic(&quot;表格头字段缺失&quot;)
	}

	titles := make([]Title, 0, len(rows[0]))

	for i := 0; i &amp;lt; len(rows[0]); i++ {
		tmp := Title{
			Index: i,
			Field: &quot;&quot;,
			Name:  rows[0][i],
		}

		//匹配头部标题
		for j := 0; j &amp;lt; t.NumField(); j++ {
			if strings.Trim(tmp.Name, &quot; &quot;) == strings.Trim(t.Field(j).Tag.Get(&quot;h&quot;), &quot; &quot;) {
				tmp.Field = t.Field(j).Name
				tmp.FieldIndex = j
			}
		}
		titles = append(titles, tmp)
	}

	for i := 1; i &amp;lt; len(rows); i++ {
		info := reflect.New(t).Elem()
		for j := 0; j &amp;lt; len(titles); j++ {
			value := &quot;&quot;
			if len(rows[i]) &amp;gt; titles[j].Index {
				value = rows[i][titles[j].Index]
			}

			f := info.Field(titles[j].FieldIndex)
			switch f.Kind() {
			case reflect.String:
				f.SetString(value)
			case reflect.Ptr:

			}
		}
		v.Set(reflect.Append(v, info))
	}
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type HelpApplyListRow struct {
	Id               string      `json:&quot;id&quot;  h:&quot;ID&quot;`
	Title            string      `json:&quot;title&quot;  h:&quot;援助室名称&quot;`            //援助室名称
	PatientName      string      `json:&quot;patient_name&quot;  h:&quot;被援助人&quot;`       //被援助人
	Content          string      `json:&quot;content&quot;  h:&quot;援助内容&quot;`            //援助内容
	OrganizationId   string      `json:&quot;organization_id&quot;  h:&quot;申请机构id&quot;`  //申请机构id
	OrganizationName string      `json:&quot;organization_name&quot;  h:&quot;申请机构&quot;`  //申请机构
	Status           string      `json:&quot;status&quot;  h:&quot;申请状态&quot;`             //申请状态
	StatusValue      string      `json:&quot;status_value&quot;  h:&quot;申请状态映射值&quot;` //申请状态映射值
	State            string      `json:&quot;state&quot;  h:&quot;援助状态&quot;`              //援助状态
	StateValue       string      `json:&quot;state_value&quot;  h:&quot;援助状态映射值&quot;`  //援助状态映射值
	CreatorName      string      `json:&quot;creator_name&quot;  h:&quot;申请人姓名&quot;`     //申请人姓名
	Reason           string      `json:&quot;reason&quot;  h:&quot;拒绝原因&quot;`             //拒绝原因
	StartAt          *gtime.Time `json:&quot;start_at&quot;  h:&quot;开始时间&quot;`           //开始时间
	EndAt            *gtime.Time `json:&quot;end_at&quot;  h:&quot;结束时间&quot;`             //结束时间
}


func main() {

	//数据导入到excel
	//data := getData(100)
	//reflects.ExportExcel(&quot;./document.xlsx&quot;, &quot;文章列表&quot;, data)
	//
	//data2 := getData2(1000)
	//reflects.ExportExcel(&quot;./applyhelp.xlsx&quot;, &quot;援助申请&quot;, data2)
	
	path, err := os.Getwd()
	if err != nil {
		panic(err)
	}

	var list []HelpApplyListRow

	reflects.ImportDb(path+&quot;/applyhelp.xlsx&quot;, &amp;amp;list)
	
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>张艳冲</name></author><category term="go" /><summary type="html">``` 我想让你知道： 1、反射可以将interface类型变量转换称反射对象 2、反射可以将反射对象还原成interface对象 3、反射对象可以修改，value值必须是可设置的</summary></entry><entry><title type="html">偷偷的告诉你go语言map的底层实现是这样的</title><link href="http://localhost:4000/2021/12/01/map%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="alternate" type="text/html" title="偷偷的告诉你go语言map的底层实现是这样的" /><published>2021-12-01T00:00:00+08:00</published><updated>2021-12-01T00:00:00+08:00</updated><id>http://localhost:4000/2021/12/01/%20map%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86</id><content type="html" xml:base="http://localhost:4000/2021/12/01/map%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">&lt;p&gt;偷偷的告诉你go语言map的底层实现是这样的&lt;/p&gt;

&lt;h2 id=&quot;map的底层实现&quot;&gt;map的底层实现？&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;map底层是用hash表实现的，一个hash表有多个bucket，而每个bucket保存map中的一个或多组键值对
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2map底层结构是hmap&quot;&gt;2、map底层结构是hmap&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type hmap struct {
	count      int            //当前保存元素的个数
	B          uint           //bucket 数组大小
	buckets    unsafe.Pointer //bucket数组，数组长度为2^B
	oldbuckets unsafe.Pointer //老旧bucket数组，用于扩容
}
每个元素经过hash运算后会落到每个桶中
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3bucket数据结构&quot;&gt;3、bucket数据结构&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type bmap struct {
	tophash  [8]uint8 //存储hash值的高8位
	data     []byte   //key value  数据：key/key/key/key/key..../value/value/value/value
	overflow *bmap    //溢出bucket的地址
}

1）hash值相同的键存入当前桶的时候，会将hash值高8位存储在该数组中,以便后续匹配
2）data存放的是key-value数据，存放顺序是key/key/key/key/key..../value/value/value/value ,
   如此存放是为了节省字节对齐带来的空间浪费
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;4hash冲突&quot;&gt;4、hash冲突&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当有两个或者以上数量的键被hash到了同一个桶时，我们称这些键发生了冲突，go使用链地址法来解决键冲突。
由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似
链表的方式将bucket连接起来。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;5负载因子&quot;&gt;5、负载因子&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;负载因子用于衡量一个hash表冲突的情况，公示为
负载因子 = 键数量/bucket 数量

负载因子过小或过大都不理想
负载因子过大，说明冲突严重，存储效率低

负载因子过小，可能预分配的空间空间太大，也可能是大部分元素被删除造成的。随着元素不断的添加到map中
负载因子会逐渐升高

负载因子过大，需要申请更多的bucket，并对所有的键值对重新组织，使其均匀的分布到这些bucket中，这个过程叫rehash.
go语言中map的负载因子达到6.5会触发rehash。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;6扩容条件&quot;&gt;6、扩容条件&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;负载因子大于6.5
overflow的数量大于2^15
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;7增量扩容&quot;&gt;7、增量扩容&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当负载因子过大时，就会新建一个bucket数组，新的bucket数组的长度是原来的2倍，然后旧的bucket数组中的数据搬迁到新的
bucket数组中。
考虑到map存储了数亿亿计的键值对，那么一次搬迁会造成较大的延迟，go采用逐步搬迁策略，每次访问map的时会触发一次搬迁，每次
搬迁两个键值对
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;8等量扩容&quot;&gt;8、等量扩容&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;就是重新搬迁，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存储速度。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;9增删改查&quot;&gt;9、增删改查&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;查找过程
1）根据key值计算hash值
2）取hash值低位与hmap.B取模来确定bucket的位置
3）取hash值高位，在tophash数组中查询定位到key高八位位置
4）在data数组中通过key在tophash高8位对应的位置找到对应的key
5) 比较要找的key是否在data数组中，如果存在，就取key对应的value
6) 如果没有找到，就继续从溢出的bucket中查找
7）如果当前map处于搬迁的过程，那么优先从oldbuckets 数组中查找，不再从新的buckets数组中查找
8) 如果查询不到，那么也不会返回nil,而是会返回相应类型的零值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>张艳冲</name></author><category term="go" /><summary type="html">偷偷的告诉你go语言map的底层实现是这样的</summary></entry><entry><title type="html">mongo分片</title><link href="http://localhost:4000/2021/04/28/mongo%E7%9A%84%E5%88%86%E7%89%87/" rel="alternate" type="text/html" title="mongo分片" /><published>2021-04-28T00:00:00+08:00</published><updated>2021-04-28T00:00:00+08:00</updated><id>http://localhost:4000/2021/04/28/mongo%E7%9A%84%E5%88%86%E7%89%87</id><content type="html" xml:base="http://localhost:4000/2021/04/28/mongo%E7%9A%84%E5%88%86%E7%89%87/">&lt;p&gt;1.mongdb 版本  –4.2 版本    （bind_ip 只能绑定一个ip 我草 无情）&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;分片服务 （副本集）  mongo3.4 以后必须的  &lt;br /&gt;
配置服务器（副本集） mongo 3.4 以后必须的&lt;br /&gt;
routes 路由 mongos   （可以一台）    &lt;br /&gt;
什么是副本集，自己百度一下  （就是有mongo主服务器，多个从服务器 当某个从服务器挂了 主服务器会从服务器找个运行正常的使用，如果主服务器挂了 就从从服务器找个作为主服务器） 一般为3个一个副本集 &lt;br /&gt;
每个副本集请至少保证剩余2台机器，否则不能用，如果多台机器挂掉后剩余2台后，不能再挂掉，否则不能使用 （&amp;lt;2 台 副本集就不能用了 ）   （自己测试）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.安装  暂时没有使用默认端口 （只在一台做实验）&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  routes         
    127.0.0.1     27000  
  配置服务器 （一个副本集）   config_set  
    127.0.0.1     27001  
    127.0.0.1     27002  
    127.0.0.1     27003   
  分片节点    （2个副本集） share1  
    127.0.0.1     27004  
    127.0.0.1     27005   
    127.0.0.1     27006  

    127.0.0.1     27007   share2  
    127.0.0.1     27008  
    127.0.0.1     27009     4.创建文件夹     data  数据文件下目录    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

  		config1 config2 config3 mongos  share1_1 share1_2 share1_3  share2_1   share2_2  share2_3 
&lt;p&gt;log  日志&lt;br /&gt;
  config 配置文件&lt;br /&gt;
  pid  文件夹&lt;br /&gt;
 5.先启动配置服务器  副本集&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	config1.conf
	logpath=/zyc/mongo_share/log/config1.log
	pidfilepath=/zyc/mongo_share/pid/config1.pid
	logappend=true
	port=27001  
	fork=true
	dbpath=/zyc/mongo_share/data/config1/
	configsvr=true   # 在配置文件添加此项就行
	oplogSize=512
	replSet=config_set
	
	
	config2.conf
	logpath=/zyc/mongo_share/log/config2.log
	pidfilepath=/zyc/mongo_share/pid/config2.pid
	logappend=true
	port=27002  
	fork=true
	dbpath=/zyc/mongo_share/data/config2/
	configsvr=true   # 在配置文件添加此项就行
	oplogSize=512
	replSet=config_set
	
	config3.conf
	logpath=/zyc/mongo_share/log/config3.log
	pidfilepath=/zyc/mongo_share/pid/config3.pid
	logappend=true
	port=27003  
	fork=true
	dbpath=/zyc/mongo_share/data/config3/
	configsvr=true   # 在配置文件添加此项就行
	oplogSize=512
	replSet=config_set
	
	
	
	 ./mongod  -f   /zyc/mongo_share/config/config1.conf
	 ./mongod  -f   /zyc/mongo_share/config/config2.conf
	  ./mongod -f   /zyc/mongo_share/config/config3.conf
	
	
	
	mongo 操作
	./mongo --port 27001
	use admin
	
	config = { _id:&quot;config_set&quot;,members:[ {_id:0,host:&quot;127.0.0.1:27001&quot;}, {_id:1,host:&quot;127.0.0.1:27002&quot;}, {_id:2,host:&quot;127.0.0.1:27003&quot;}] }        #定义副本集
	
	rs.initiate(config) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;6  启动mongos 路由服务器&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ./mongos  -f /zyc/mongo_share/config/mongos.conf

	mongos.conf  其中的config_set 跟上面的匹配
	logpath=/zyc/mongo_share/log/mongos.log
	pidfilepath=/zyc/mongo_share/pid/mongos.pid
	logappend=true
	port=27000
	fork=true
	configdb=config_set/127.0.0.1:27001,127.0.0.1:27002,127.0.0.1:27003
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;7.分片副本集配置   2个副本集&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  第一组分片
   share1_1.conf
logpath=/zyc/mongo_share/log/share1_1.log
pidfilepath=/zyc/mongo_share/pid/share1.pid
directoryperdb=true
logappend=true
port=27004
fork=true
dbpath=/zyc/mongo_share/data/share1_1/
oplogSize=512
replSet=share1
shardsvr=true
   
   
  share1_2.conf
logpath=/zyc/mongo_share/log/share1_2.log
pidfilepath=/zyc/mongo_share/pid/share2.pid
directoryperdb=true
logappend=true
port=27005
fork=true
dbpath=/zyc/mongo_share/data/share1_2/
oplogSize=512
replSet=share1
shardsvr=true


  share1_3.conf
logpath=/zyc/mongo_share/log/share1_3.log
pidfilepath=/zyc/mongo_share/pid/share1_3.pid
directoryperdb=true
logappend=true
port=27006
fork=true
dbpath=/zyc/mongo_share/data/share1_3/
oplogSize=512
replSet=share1
shardsvr=true




 ./mongod  -f   /zyc/mongo_share/config/share1_1.conf
 ./mongod  -f   /zyc/mongo_share/config/share1_2.conf
 ./mongod -f   /zyc/mongo_share/config/share1_3.conf   


 ./mongo --port 27004
 
 use admin

 shard = {_id:&quot;share1&quot;,members:[{_id:0,host:&quot;127.0.0.1:27004&quot;},{_id:1,host:&quot;127.0.0.1:27005&quot;}, {_id:2,host:&quot;127.0.0.1:27006&quot;}]}

 rs.initiate(shard)



 第二组分片

   share2_1.conf
logpath=/zyc/mongo_share/log/share2_1.log
pidfilepath=/zyc/mongo_share/pid/share2_1.pid
directoryperdb=true
logappend=true
port=27007
fork=true
dbpath=/zyc/mongo_share/data/share2_1/
oplogSize=512
replSet=share2
shardsvr=true
   
   
  share2.conf
logpath=/zyc/mongo_share/log/share2_2.log
pidfilepath=/zyc/mongo_share/pid/share2_2.pid
directoryperdb=true
logappend=true
port=27008
fork=true
dbpath=/zyc/mongo_share/data/share2_2/
oplogSize=512
replSet=share2
shardsvr=true


  share3.conf
logpath=/zyc/mongo_share/log/share2_3.log
pidfilepath=/zyc/mongo_share/pid/share2_3.pid
directoryperdb=true
logappend=true
port=27009
fork=true
dbpath=/zyc/mongo_share/data/share2_3/
oplogSize=512
replSet=share2
shardsvr=true




 ./mongod  -f   /zyc/mongo_share/config/share2_1.conf
 ./mongod  -f   /zyc/mongo_share/config/share2_2.conf
 ./mongod -f   /zyc/mongo_share/config/share2_3.conf   


 ./mongo --port 27007
 
 use admin

 shard = {_id:&quot;share2&quot;,members:[{_id:0,host:&quot;127.0.0.1:27007&quot;},{_id:1,host:&quot;127.0.0.1:27008&quot;}, {_id:2,host:&quot;127.0.0.1:27009&quot;}]}

 rs.initiate(shard)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;8.启动mongos 路由数据库 添加分片集
	 ./mongo –port 27000&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sh.addShard(&quot;share1/127.0.0.1:27004,127.0.0.1:27005,127.0.0.1:27006&quot;);
 sh.addShard(&quot;share2/127.0.0.1:27007,127.0.0.1:27008,127.0.0.1:27009&quot;);


 sh.status()  
   查看shards  判断是否成功



-个集合只有且只能有一个分片键，一旦分片键确定好之后就不能更改  （重要呀）
  8.1 hash分片 指定zyc数据库开始分片  
   sh.enableSharding(&quot;zyc&quot;)  需要分片的数据库       
   sh.shardCollection(&quot;zyc.nihao&quot;,{&quot;id&quot;:&quot;hashed&quot;})     //已hash的方式分片  最主要的用这个 

	for(let i=10000;i&amp;lt;90000;i++){
	    db.nihao.insert({&quot;name&quot;:&apos;name&apos;+i,&quot;id&quot;:i});
	}

	//查看分片的情况
	db.nihao.getShardDistribution()


 8.2 range 分片  有个默认块 一般大于64M 才会均衡数据

 测试  改变一下块大小否则数据太小无法看出来
  use config
  db.settings.save({_id: &quot;chunksize&quot;, value: 2})
  db.settings.find({_id: &quot;chunksize&quot;})


  sh.enableSharding(&quot;zyc&quot;)  需要分片的数据库  
  sh.shardCollection(&quot;zyc.shenghuo&quot;,{&quot;userid&quot;:1})     

  for (i= 10000; i &amp;lt;=200000; i++){
   db.shenghuo.insert({age:(i%100), name:&quot;user&quot;+i,userid:i})
  } 

  //查看分片的情况
	db.nihao.getShardDistribution()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>张艳冲</name></author><category term="mongo" /><summary type="html">1.mongdb 版本 –4.2 版本 （bind_ip 只能绑定一个ip 我草 无情） 分片服务 （副本集） mongo3.4 以后必须的 配置服务器（副本集） mongo 3.4 以后必须的 routes 路由 mongos （可以一台） 什么是副本集，自己百度一下 （就是有mongo主服务器，多个从服务器 当某个从服务器挂了 主服务器会从服务器找个运行正常的使用，如果主服务器挂了 就从从服务器找个作为主服务器） 一般为3个一个副本集 每个副本集请至少保证剩余2台机器，否则不能用，如果多台机器挂掉后剩余2台后，不能再挂掉，否则不能使用 （&amp;lt;2 台 副本集就不能用了 ） （自己测试） 3.安装 暂时没有使用默认端口 （只在一台做实验） routes 127.0.0.1 27000 配置服务器 （一个副本集） config_set 127.0.0.1 27001 127.0.0.1 27002 127.0.0.1 27003 分片节点 （2个副本集） share1 127.0.0.1 27004 127.0.0.1 27005 127.0.0.1 27006</summary></entry><entry><title type="html">你说你搞懂了defer？我不信！</title><link href="http://localhost:4000/2020/12/20/%E4%BD%A0%E8%AF%B4%E4%BD%A0%E6%90%9E%E6%87%82%E4%BA%86defer/" rel="alternate" type="text/html" title="你说你搞懂了defer？我不信！" /><published>2020-12-20T00:00:00+08:00</published><updated>2020-12-20T00:00:00+08:00</updated><id>http://localhost:4000/2020/12/20/%20%E4%BD%A0%E8%AF%B4%E4%BD%A0%E6%90%9E%E6%87%82%E4%BA%86defer</id><content type="html" xml:base="http://localhost:4000/2020/12/20/%E4%BD%A0%E8%AF%B4%E4%BD%A0%E6%90%9E%E6%87%82%E4%BA%86defer/">&lt;p&gt;defer不仅可以用于资源释放，也可以用于流程控制和异常处理，但defer关键字只能用于函数或函数调用。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;defer关键字后接一个匿名函数
defer func(){
    fmt.Println(&quot;hello world!&quot;)
}

defer关键字后接一个函数调用：
file,err :=os.open(name)
if err != nil {

   return nil,err
}
defer file.Close()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;1使用场景&quot;&gt;1、使用场景&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1）释放资源
m.mutex.Lock()
defer m.mutex.Unlock()
defer 常用于文件句柄、数据库连接，停止定时器 Ticker 以及关闭管道等资源清理场景 。

2）流程控制
var wg wait.group
defer wg.Wait()
defer 也用于控制函数的执行顺序，比如配合wait.Group实现等待携程的退出。 

3）异常处理
defer 常用于处理异常，与recover配合可以消除panic,另外recover只能用于defer函数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2行为规则&quot;&gt;2、行为规则&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1）规则一：延迟函数的参数在defer语句出现的时候就已经确定了
官方给出的例子如下图所示：
func f(){
    i :=0
    defer fmt.Println(i)
    i++
    return
}

defer语句中的fmt.Println()参数i值在defer出现时就已经确定了，实际上是复制了一份。后面对变量i的修改
不会影响fmt.Println()函数的执行，仍然打印0。

2) 规则二：延迟函数按照先进后出的顺序执行，也就是说在函数中，最先出现的defer最后执行。


3）规则三：延迟函数可能影响主函数的返回值
定义defer的函数可能有名字的返回值，也可能是没名字的返回值！延迟函数可能会影响到返回值。

那如果想要理解延迟函数是如何影响主函数返回值的，只要明白函数是如何返回就够了。
（1）有个事实必须要清楚，关键字return不是一个原子操作，实际上return只代表汇编指令ret,即跳转程序的执行。
    比如return i,实际上是分两步执行，即先将i值存入栈中作为返回值，然后执行跳转，而defer的执行时机介于返回值
    入栈与跳转之间。这意味着defer是有机会操作返回值的。
    
    那举个例子：
    func deferResult() (res int){
        i :=1
        
        defer func(){
            res++
        }
    
        return i    
    }
    该函数的return语句可以拆分成下面两行：
    result = i
    return
    前面说过延迟函数在return之前执行
    result = i //1
    result++ //2
    return
    
    所以上面的返回值是 result++ 的值
    
   （2）主函数有匿名函数返回值，则返回字面值。
    一个主函数拥有一个匿名返回值，比如说1，2，3，&quot;hello&quot;等，那么defer是无法操作返回值的
    比如下面一个返回字面值的函数：
    func f() int{
        var i int
        defer func(){
            i++
        }
        return 1
    }
    
    上面的return语句直接把1写入栈中作为返回值，延迟函数无法操作该返回值，索引就无法影响到该返回值。
    
   （3）主函数拥有匿名返回值，返回变量。
    一个主函数拥有一个匿名返回值，返回本地变量或者局部变量，这种情况下defer可以引用返回值，但不会改变返回值。
    一个返回本地变量的函数如下：
    func f() int{
      var i int
      defer func (){
        i++
      }
      return i
    
    }
    
    上面的函数返回一个局部变量，同时defer函数也会操作这个局部变量。对于一个匿名返回值来说，可以假定一个匿名变量
    来存储该返回值，那么上面的返回值可以拆分以下步骤：
    
    anony = i
    i++
    return
    
    由于i是整数，会将值复制给anony,所以defer语句中的修改不会函数返回值造成影响

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>张艳冲</name></author><category term="go" /><summary type="html">defer不仅可以用于资源释放，也可以用于流程控制和异常处理，但defer关键字只能用于函数或函数调用。</summary></entry></feed>